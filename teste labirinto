def ler_arquivo(arquivo):
    #leitura de arquivo usando caminho absoluto
    arquivo = "c:/Users/julia/OneDrive/Documentos/UFOP/2022-2/AEDS3/TP1/maze/toy.txt"
    
    with open(arquivo) as f:
        labirinto = [linha.strip() for linha in f]
        altura = len(labirinto)
        largura = len(labirinto[0])
        grafo = {}
        print(grafo)
        
    #transformando em grafo o arquivo lido armazenando na lista labirinto e o resultado final no dicionário grafo
    for i in range(altura):
        for j in range(largura):
            if labirinto[i][j] == " ":
                vertice = (i, j)
                vizinhos = []
                if i > 0 and labirinto[i-1][j] == " ":
                    vizinhos.append((i-1, j))
                if i < altura-1 and labirinto[i+1][j] == " ":
                    vizinhos.append((i+1, j))
                if j > 0 and labirinto[i][j-1] == " ":
                    vizinhos.append((i, j-1))
                if j < largura-1 and labirinto[i][j+1] == " ":
                    vizinhos.append((i, j+1))
                grafo[vertice] = vizinhos
    return grafo
#busca em profundidade
import time

def dfs(grafo, vertice_inicial, vertice_final, caminho=[]):
    pilha = [(vertice_inicial, caminho)]
    visitados = set()
    while pilha:
        vertice, caminho = pilha.pop()
        if vertice in visitados:
            continue
        visitados.add(vertice)
        caminho = caminho + [vertice]
        if vertice == vertice_final:
            return caminho
        for vizinho in grafo[vertice]:
            pilha.append((vizinho, caminho))
    return None

inicio = time.time()
caminho = dfs(grafo, vertice_inicial, vertice_final)
fim = time.time()

if caminho is None:
    print("Não foi possível encontrar uma saída")
else:
    print("Caminho encontrado:", caminho)
    print("Tempo gasto:", fim - inicio, "segundos")
